import { writeFileSync, mkdirSync, copyFileSync } from 'node:fs';
import { Command } from '@commander-js/extra-typings';
import { resolve, dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

import { generateConfigHash, attemptToReadTOMLData, validateConfigFile  } from '@wfp/common-identifier-algorithm-shared';
import type { Config } from '@wfp/common-identifier-algorithm-shared';

const __dirname = dirname(fileURLToPath(import.meta.url));

const program = new Command()
  .requiredOption('--algorithm-name <ALGORITHM_NAME>', 'Algorithm name for this algorithm deployment, typically the directory name in the algorithms repository.');
program.parse();


/* Script functions: 
  - validate the selected algorithm exposes the correct API (shallow only)
  - check the signature of the backup configuration file
  - copy the backup configuration file to the assets/ directory for bundling with electron
  - expose the correct types for the imported algorithm by generating common/selected-algo.d.ts
*/ 
(async () => {
  const target = `@wfp/common-identifier-algorithms/${program.opts().algorithmName}`;
  const { configPath, algorithmId } = await validateAlgorithmTarget(target);

  if (!checkConfigSignature(configPath, algorithmId))
    throw new Error(`Could not validate backup configuration file: ${configPath}, ${algorithmId}`);

  // TODO: Investigate pulling the config file directly from @selected-algo/config/config.toml.
  //       For now, we are copying the config file to the assets directory here instead of fetching it from the target module during
  //       runtime. This is simpler, but annoying. It would be better to pull the backup config file from the algorithm library itself,
  //       but we then run into issues exposing it from the bundled app.asar.
  const assetsDir = resolve(__dirname, '../assets');
  const configDest = resolve(assetsDir, 'config.backup.toml')

  console.log('INFO: Copying backup config from', configPath);
  console.log('                              to', configDest);
  mkdirSync(assetsDir, { recursive: true });
  copyFileSync(configPath, resolve(assetsDir, 'config.backup.toml'));

  generateAlgorithmTypes(target);
})()


async function validateAlgorithmTarget(target: string) {
  // A correctly defined algorithm should expose an ALGORITHM_ID, a makeHasher function, and provide a backup config file
  console.log(`INFO: Validating imported resource '${target}'`);
  let importCheck;

  try {
    importCheck = await import(target);
  } catch {
    throw new Error(`Unable to import algorithm '${program.opts().algorithmName} from ${target}'`);
  }

  if (typeof(importCheck.ALGORITHM_ID) !== "string") throw new Error(`Imported resource from ${target} does not export ALGORITHM_ID`);
  if (typeof(importCheck.makeHasher) !== "function") throw new Error(`Imported resource from ${target} does not export makeHasher function`);
  if (typeof(importCheck.getConfigPath) !== "function") throw new Error(`Imported resource from ${target} does not export a getConfigPath function`);

  console.log(`INFO: Successfully validated resource '${target}'`);
  return { configPath: importCheck.getConfigPath(), algorithmId: importCheck.ALGORITHM_ID }
}

function checkConfigSignature(filePath: string, algorithmId: string) {
  const config = attemptToReadTOMLData<Config.FileConfiguration>(filePath, "utf-8");
  if (!config) {
    console.error(`ERROR: could not read configuration file: ${filePath}`);
    return false;
  }

  const validationResult = validateConfigFile(config, algorithmId);
  if (!!validationResult) {
    console.error(`ERROR: could not validate configuration file: ${validationResult}`);
    return false;
  }
  const hash = generateConfigHash(config);

  if (hash !== config.meta.signature) {
    console.error(`ERROR: configuration file contains invalid signature`)
    console.error(`       EXPECTED: ${hash}`);
    console.error(`            GOT: ${config.meta.signature}`);
    return false;
  }
  return true;
}

async function generateAlgorithmTypes(target: string) {
  console.log(`INFO: Generating types for exported resource '${target}'`);
  
  const dts = `// AUTO-GENERATED. Do not edit. Generated by scripts/activate-algorithm.ts
declare module '@selected-algo' {
  export * from '${target}';
}
`;
    
  const outDir = resolve(__dirname, '../common');
  mkdirSync(outDir, { recursive: true });
  writeFileSync(resolve(outDir, 'selected-algo.d.ts'), dts);

  console.log(`INFO: Types successfully written to '../common/selected-algo.d.ts'`);
  return true;
}
